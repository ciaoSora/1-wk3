# **Binary Code**

1) int8_t x = 67; int8_t y = -7; int8_t z = y - x;

x = 01000011, y = 11111001, z = 10110110.

No overflow error.

2) int8_t x = 0xd3;

x = 11010011.

x overflows.

3) uint8_t x = 0xd3;

x = 11010011.

No overflow error.

4) int8_t x = 127; int8_t y = -7; int8_t z = y – x;

x = 01111111, y = 11111001, z = 01111010.

z overflows.

5) float x = 1.125;

x = 0 01111111 00100000000000000000000

No overflow error. No accuracy error.

6) float x = 23.0;

x = 0 10000011 01110000000000000000000

No overflow error. No accuracy error.

7) float x = 0.45;

x = 0 01111101 11001100110011001100110

No overflow error. x has an accuracy error.

<br/>

# **Explanation of Some Words**

The following explanations are all from Wikipedia.

## *Method of complements*

In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers.

在数学和计算科学领域，补码是一种技术，它用一个正数之和来减去一个数。

## *Byte*

The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number.

字节是一个单位的数字信息，它通常包括8位，代表一个二进制数。

## *Integer (computer science)*

In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers.

在计算机科学领域，一个整数是一种表示整型数的数据，是一种表示一定范围的数学意义上的整数的数据类型。

## *Floating point*

In computing, floating-point arithmetic (FP) is arithmetic using formulaic representation of real numbers as an approximation so as to support a trade-off between range and precision.

在计算科学领域，浮点算术（FP）是用格式化表示的实数作为估计值的算术，它支持范围和精度之间的取舍。

<br/>

# **Problems about "Method of complements"**

1) 补码正确性证明.

证：

设这是个n位二进制数，设p = 2<sup>n</sup>.

以下证明不考虑算术溢出.

由补码定义，

① f(x) = x，当x >= 0;

② f(x) = (p - 1) - |x| + 1 = p + x，当 x < 0.

可以看出f(x)必然为一个正数.

由于执行加法操作时，机器内部执行两个正数相加，并且如果最高位进位，就舍弃掉，即取除以p的余数.

所以证明补码正确性 等价于 证明f(x) + f(y)与f(x + y)同余（模p）.

又因为要么f(x) = x，要么f(x) = p + x，

所以f(x) + f(y)必然与f(x + y)同余.

证毕.

2) int8_t x = -017;

x 为 (-17)<sub>8</sub>，

由于x是一个8-bit整数，而一个八进制位代表3个bit，8不被3整除，因此取反码时不能简单以7来减去每一个八进制位，而是应该用2<sup>8</sup>来减去整个数。

对 |x| 取反码（sevens' complement），得到 (361)<sub>8</sub>.

再对反码加一，得到补码，(362)<sub>8</sub>.

<br/>

# **Problems about "Two's complement"**

1) int8_t x = -0x1f; int y = x;

x是一个8-bit整数，y为一个32-bit整数，二者皆为 (1F)<sub>16</sub>，其中y还有6个前导0，也就是说y = (0000001F)<sub>16</sub>.

对 |x| 取反码，得 (E0)<sub>16</sub>，再加一得补码 (E1)<sub>16</sub>，即x的机器内部表示为(E1)<sub>16<sub>.

同理，得到y的机器内部表示为(FFFFFFE1)<sub>16</sub>.

当x（位数较少）赋值给y（位数较多）时，机器先把y的最低8位设为x的对应位，然后再把余下的高24位全部设为x的最高位.

2) 位数少转位数多的正确性证明.

设x是位数较少的数，y是位数较多的数.

分两种情况：

① x >= 0.

此时，x的最高位为0，把y的低位设为x后，再把y的高位全部设为0，显然成立.

② x < 0.

先考虑 |x| 与 |y| 的机器内部表示，显然区别仅在于y比x多了若干个前导0. 分别取补码，显然区别仅在于y比x多了若干个前导1，而x的最高为恰恰是1，因此成立.

证毕.

<br/>

# **Problems about "Floating point"**

"NaN" 是 "Not a Number" 的缩写
