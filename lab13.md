# 字符贪吃蛇游戏设计

采用自顶向下的方法设计，先写出程序框架，然后逐步求精。

详细请参见[源码][1]

<br/>

## STEP 0：写出程序框架

```C
int validChar(char ch) {
	return ch == 'w' || ch == 'W' || ch == 'a' || ch == 'A'
		|| ch == 's' || ch == 'S' || ch == 'd' || ch == 'D';
}

int main() {
	char ch;
	init();
	output();
	while (!isGameover()) {
		while (!validChar(ch = getchar()));
		switch (ch) {
			case 'w':
			case 'W': snakeMove(-1, 0); break;
			case 's':
			case 'S': snakeMove(1, 0);  break;
			case 'a':
			case 'A': snakeMove(0, -1); break;
			case 'd':
			case 'D': snakeMove(0, 1);  break;
		}
		output();
	}
	gameover();
	system("pause");
	return 0;
}
```

<br/>

## STEP 1：考虑如何使蛇能移动

最关键的在于snakeMove如何写。显然，如果有一种数据结构记录了蛇的每一部分的坐标，那么队列是最适合的，因为蛇符合先进先出的特点：移动了一格后，队头弹出一个元素（即蛇的身体尾端），再把蛇头新进入的格子压入队尾，注意到队列的头尾和蛇的头尾刚好是相反的。这样以来，蛇便能移动了，但是仍然不能吃食物，不能撞墙（吃墙？），不能吃自己。

<br/>

## STEP2: 考虑如何使蛇能吃东西
先考虑如何随机生成食物。可以先取得目前存储蛇的坐标的队列的元素个数，也即为蛇的长度，用地图总大小减去这个数即为空格子数目，暂时称作 n。这样以来，只需生成一个[0, n)之间的随机整数 x 即可，就取第 x 个空格子作为放置食物的格子。虽然每次生成食物都要把整个地图遍历一遍，效率略低，但是重新生成食物的机会不多，所以没什么关系。（何况地图还这么小，更没关系了）

再考虑如何吃食物。本来，移动一步，队列就要弹出蛇尾，压入蛇头；现在，当下一步就要吃食物时，不需要弹出蛇尾了，直接压入蛇头即可，因为蛇的身体变长了一节，食物的位置成为蛇的一部分了。

最后再完善一下吃自己和吃墙的判断即可，这二者都不复杂，前者只需判断蛇头是否与其他蛇的部分重合，后者只需判断蛇头是否还在地图内部即可。

[1]: https://github.com/ciaoSora/CharSnakeDummy
